<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GoF++: BACKENDS</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">GoF++<span id="projectnumber">&#160;0.1</span>
   </div>
   <div id="projectbrief">Game of Four pattern library for C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">BACKENDS</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>_(You may browse this at <a href="https://github.com/ocornut/imgui/blob/master/docs/BACKENDS.md">https://github.com/ocornut/imgui/blob/master/docs/BACKENDS.md</a> or view this file with any Markdown viewer)_</p>
<h1><a class="anchor" id="autotoc_md44"></a>
Dear ImGui: Backends</h1>
<h2><a class="anchor" id="autotoc_md45"></a>
Index</h2>
<ul>
<li>Introduction<ul>
<li>Getting Started</li>
<li>What are Backends?</li>
</ul>
</li>
<li>Using standard Backends</li>
<li>Using third-party Backends</li>
<li>Writing your own Backend<ul>
<li>Using a custom engine?</li>
<li>Platform: Implementing your Platform Backend</li>
<li>Rendering: Implementing your RenderDrawData function</li>
<li>Rendering: Adding support for `ImGuiBackendFlags_RendererHasTextures` (1.92+)</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md46"></a>
Introduction</h2>
<h3><a class="anchor" id="autotoc_md47"></a>
Getting Started</h3>
<p>ðŸ’¡ The <b><a href="https://github.com/ocornut/imgui/wiki/Getting-Started">Getting Started</a> wiki guide</b> has examples of how to integrate Dear ImGui into an existing application. <br  />
 The <a href="https://github.com/ocornut/imgui/blob/master/docs/EXAMPLES.md">EXAMPLES.MD</a> documentation may also be worth a read.</p>
<h3><a class="anchor" id="autotoc_md48"></a>
What are Backends?</h3>
<p>Dear ImGui is highly portable and only requires a few things to run and render, typically:</p>
<ul>
<li>Required: providing mouse/keyboard inputs (fed into the <code>ImGuiIO</code> structure).</li>
<li>Required: creating, updating and destroying textures.</li>
<li>Required: rendering indexed textured triangles with a clipping rectangle.</li>
</ul>
<p>Extra features are opt-in, our backends try to support as many as possible:</p>
<ul>
<li>Optional: custom texture binding support.</li>
<li>Optional: clipboard support.</li>
<li>Optional: gamepad support.</li>
<li>Optional: mouse cursor shape support.</li>
<li>Optional: IME support.</li>
<li>Optional: multi-viewports support. etc.</li>
</ul>
<p>This is essentially what each backend is doing + obligatory portability cruft. Using standard backends ensure you can get all those features including the ones that would be harder to implement on your side (e.g. multi-viewports support).</p>
<p>It is important to understand the difference between the core Dear ImGui library (files in the root folder) and the backends which we are describing here (backends/ folder).</p>
<ul>
<li>Some issues may only be backend or platform specific.</li>
<li>You should be able to write backends for pretty much any platform and any 3D graphics API. e.g. you can get creative and use software rendering or render remotely on a different machine.</li>
</ul>
<h2><a class="anchor" id="autotoc_md49"></a>
Using standard Backends</h2>
<p><b>The <a href="https://github.com/ocornut/imgui/blob/master/backends">backends/</a> folder contains backends for popular platforms/graphics API, which you can use in your application or engine to easily integrate Dear ImGui.</b> Each backend is typically self-contained in a pair of files: imgui_impl_XXXX.cpp + imgui_impl_XXXX.h.</p>
<ul>
<li>The 'Platform' backends are in charge of: mouse/keyboard/gamepad inputs, cursor shape, timing, and windowing.<br  />
 e.g. Windows (<a href="https://github.com/ocornut/imgui/blob/master/backends/imgui_impl_win32.cpp">imgui_impl_win32.cpp</a>), SDL3 (<a href="https://github.com/ocornut/imgui/blob/master/backends/imgui_impl_sdl3.cpp">imgui_impl_sdl3.cpp</a>), GLFW (<a href="https://github.com/ocornut/imgui/blob/master/backends/imgui_impl_glfw.cpp">imgui_impl_glfw.cpp</a>), etc.</li>
<li>The 'Renderer' backends are in charge of: creating atlas texture, and rendering imgui draw data.<br  />
 e.g. DirectX11 (<a href="https://github.com/ocornut/imgui/blob/master/backends/imgui_impl_dx11.cpp">imgui_impl_dx11.cpp</a>), OpenGL/WebGL (<a href="https://github.com/ocornut/imgui/blob/master/backends/imgui_impl_opengl3.cpp">imgui_impl_opengl3.cpp</a>), Vulkan (<a href="https://github.com/ocornut/imgui/blob/master/backends/imgui_impl_vulkan.cpp">imgui_impl_vulkan.cpp</a>), etc.</li>
<li>For some high-level frameworks, a single backend usually handles both 'Platform' and 'Renderer' parts.<br  />
 e.g. Allegro 5 (<a href="https://github.com/ocornut/imgui/blob/master/backends/imgui_impl_allegro5.cpp">imgui_impl_allegro5.cpp</a>). If you end up creating a custom backend for your engine, you may want to do the same.</li>
</ul>
<p>An application usually combines one Platform backend + one Renderer backend + main Dear ImGui sources. For example, the <a href="https://github.com/ocornut/imgui/tree/master/examples/example_win32_directx11">example_win32_directx11</a> application combines imgui_impl_win32.cpp + imgui_impl_dx11.cpp. There are 20+ examples in the <a href="https://github.com/ocornut/imgui/blob/master/examples/">examples/</a> folder. See <a href="https://github.com/ocornut/imgui/blob/master/docs/EXAMPLES.md">EXAMPLES.MD</a> for details.</p>
<p><b>Once Dear ImGui is setup and running, run and refer to <code>ImGui::ShowDemoWindow()</code> in imgui_demo.cpp for usage of the end-user API.</b></p>
<h3><a class="anchor" id="autotoc_md50"></a>
List of standard Backends</h3>
<p>In the <a href="https://github.com/ocornut/imgui/blob/master/backends">backends/</a> folder:</p>
<p>List of Platforms Backends: </p><pre class="fragment">imgui_impl_android.cpp      ; Android native app API
imgui_impl_glfw.cpp         ; GLFW (Windows, macOS, Linux, etc.) http://www.glfw.org/
imgui_impl_osx.mm           ; macOS native API (not as feature complete as glfw/sdl backends)
imgui_impl_sdl2.cpp         ; SDL2 (Windows, macOS, Linux, iOS, Android) https://www.libsdl.org
imgui_impl_sdl3.cpp         ; SDL3 (Windows, macOS, Linux, iOS, Android) https://www.libsdl.org
imgui_impl_win32.cpp        ; Win32 native API (Windows)
imgui_impl_glut.cpp         ; GLUT/FreeGLUT (this is prehistoric software and absolutely not recommended today!)
</pre><p> List of Renderer Backends: </p><pre class="fragment">imgui_impl_dx9.cpp          ; DirectX9
imgui_impl_dx10.cpp         ; DirectX10
imgui_impl_dx11.cpp         ; DirectX11
imgui_impl_dx12.cpp         ; DirectX12
imgui_impl_metal.mm         ; Metal (ObjC or C++)
imgui_impl_opengl2.cpp      ; OpenGL 2 (legacy fixed pipeline. Don't use with modern OpenGL code!)
imgui_impl_opengl3.cpp      ; OpenGL 3/4, OpenGL ES 2/3, WebGL
imgui_impl_sdlgpu3.cpp      ; SDL_GPU (portable 3D graphics API of SDL3)
imgui_impl_sdlrenderer2.cpp ; SDL_Renderer (optional component of SDL2 available from SDL 2.0.18+)
imgui_impl_sdlrenderer3.cpp ; SDL_Renderer (optional component of SDL3. Prefer using SDL_GPU!).
imgui_impl_vulkan.cpp       ; Vulkan
imgui_impl_wgpu.cpp         ; WebGPU (web + desktop)
</pre><p> List of high-level Frameworks Backends (combining Platform + Renderer): </p><pre class="fragment">imgui_impl_allegro5.cpp
</pre><p> Emscripten is also supported! The SDL2+GL, SDL3+GL, GLFW+GL and GLFW+WebGPU examples are all ready to build and run with Emscripten.</p>
<h3><a class="anchor" id="autotoc_md51"></a>
Recommended Backends</h3>
<p>If you are not sure which backend to use, the recommended platform/frameworks for portable applications:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Library   </th><th class="markdownTableHeadNone">Website   </th><th class="markdownTableHeadNone">Backend   </th><th class="markdownTableHeadNone">Note    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">SDL3   </td><td class="markdownTableBodyNone"><a href="https://www.libsdl.org">https://www.libsdl.org</a>   </td><td class="markdownTableBodyNone">imgui_impl_sdl3.cpp   </td><td class="markdownTableBodyNone">Recommended    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">SDL2   </td><td class="markdownTableBodyNone"><a href="https://www.libsdl.org">https://www.libsdl.org</a>   </td><td class="markdownTableBodyNone">imgui_impl_sdl2.cpp   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">GLFW   </td><td class="markdownTableBodyNone"><a href="https://github.com/glfw/glfw">https://github.com/glfw/glfw</a>   </td><td class="markdownTableBodyNone">imgui_impl_glfw.cpp   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Sokol   </td><td class="markdownTableBodyNone"><a href="https://github.com/floooh/sokol">https://github.com/floooh/sokol</a>   </td><td class="markdownTableBodyNone"><a href="https://github.com/floooh/sokol/blob/master/util/sokol_imgui.h">util/sokol_imgui.h</a>   </td><td class="markdownTableBodyNone">Lower-level than GLFW/SDL   </td></tr>
</table>
<p>If your application runs on Windows or if you are using multi-viewport, the win32 backend handles some details a little better than other backends.</p>
<h2><a class="anchor" id="autotoc_md52"></a>
Using third-party Backends</h2>
<p>See <a href="https://github.com/ocornut/imgui/wiki/Bindings">https://github.com/ocornut/imgui/wiki/Bindings</a> for the full list (e.g. Adventure Game Studio, Cinder, Cocos2d-x, Game Maker Studio2, Godot, LÃ–VE+LUA, Magnum, Monogame, Ogre, openFrameworks, OpenSceneGraph, SFML, Sokol, Unity, Unreal Engine and many others).</p>
<h2><a class="anchor" id="autotoc_md53"></a>
Writing your own Backend</h2>
<h3><a class="anchor" id="autotoc_md54"></a>
Using a custom engine?</h3>
<p>You will likely be tempted to start by rewrite your own backend using your own custom/high-level facilities...<br  />
 Think twice!</p>
<p>TL;DR;</p><ul>
<li>Writing your own Renderer Backend is easy.</li>
<li>Writing your own Platform Backend is harder and you are more likely to introduce bugs.</li>
<li><b>It is unlikely you will add value to your project by creating your own backend.</b></li>
</ul>
<p><b>Consider using the existing backends as-is</b>. You will save lots of time integrating the library. Standard backends are battle-tested and handle subtleties that you are likely to implement incorrectly. You can LATER decide to rewrite yourself a custom backend if you really need to. In most situations, custom backends have fewer features and more bugs than the standard backends we provide. If you want portability, you can use multiple backends and choose between them either at compile time or at runtime.</p>
<p><b>Example A</b>: your engine is built over Windows + DirectX11 but you have your own high-level rendering system layered over DirectX11.<br  />
 Suggestion: try using imgui_impl_win32.cpp + imgui_impl_dx11.cpp first. Once it works, if you really need it, you can replace the imgui_impl_dx11.cpp code with a custom renderer using your own rendering functions, and keep using the standard Win32 code etc.</p>
<p><b>Example B</b>: your engine runs on Windows, Mac, Linux and uses DirectX11, Metal, and Vulkan respectively.<br  />
 Suggestion: use multiple generic backends! Once it works, if you really need it, you can replace parts of backends with your own abstractions.</p>
<p><b>Example C</b>: your engine runs on platforms we can't provide public backends for (e.g. PS4/PS5, Switch), and you have high-level systems everywhere.<br  />
 Suggestion: try using a non-portable backend first (e.g. win32 + underlying graphics API) to get your desktop builds working first. This will get you running faster and get your acquainted with how Dear ImGui works and is setup. You can then rewrite a custom backend using your own engine API...</p>
<p>Also: The <a href="https://github.com/ocornut/imgui/wiki/Multi-Viewports">multi-viewports feature</a> of the 'docking' branch allows Dear ImGui windows to be seamlessly detached from the main application window. This is achieved using an extra layer to the Platform and Renderer backends, which allows Dear ImGui to communicate platform-specific requests such as: "create an additional OS window", "create a render context", "get the OS position of this
window", but some things are more difficult "find OS window under mouse position BUT with some windows marked as passthrough". See 'ImGuiPlatformIO' for details. Supporting the multi-viewports feature correctly using 100% of your own abstractions is more difficult than supporting single-viewport. If you decide to use unmodified imgui_impl_XXXX.cpp files, you can automatically benefit from improvements and fixes related to viewports and platform windows without extra work on your side.</p>
<h3><a class="anchor" id="autotoc_md55"></a>
Platform: Implementing your Platform Backend</h3>
<p>The Platform backends in impl_impl_XXX.cpp files contain many implementations.</p>
<p><b>In your <code>ImGui_ImplXXX_Init()</code> function:</b></p><ul>
<li>You can allocate your backend data and use <code>io.BackendPlatformUserData</code> to store/retrieve it later.</li>
<li>Set <code>io.BackendPlatformName</code> to a name <code>"imgui_impl_xxxx"</code> which will be available in e.g. About box.</li>
<li>Set <code>io.BackendPlatformUserData</code> to your backend data.</li>
<li>Set <code>io.BackendFlags</code> with supported optional features:<ul>
<li><code>ImGuiBackendFlags_HasGamepad</code>: supports gamepad and currently has one connected.</li>
<li><code>ImGuiBackendFlags_HasMouseCursors</code>: supports honoring GetMouseCursor() value to change the OS cursor shape.</li>
<li><code>ImGuiBackendFlags_HasSetMousePos</code>: supports io.WantSetMousePos requests to reposition the OS mouse position (only used if io.ConfigNavMoveSetMousePos is set).</li>
<li><code>ImGuiBackendFlags_PlatformHasViewports</code> supports multiple viewports. (multi-viewports only)</li>
<li><code>ImGuiBackendFlags_HasMouseHoveredViewport</code> supports calling io.AddMouseViewportEvent() with the viewport under the mouse. IF POSSIBLE, ignore viewports with the ImGuiViewportFlags_NoInputs flag. If this cannot be done, Dear ImGui needs to use a flawed heuristic to find the viewport under mouse position, as it doesn't know about foreign windows. (multi-viewports only)</li>
</ul>
</li>
</ul>
<p><b>In your <code>ImGui_ImplXXX_NewFrame()</code> function:</b></p><ul>
<li>Set <code>io.DeltaTime</code> to the time elapsed (in seconds) since last frame.</li>
<li>Set <code>io.DisplaySize</code> to your window size.</li>
<li>Set <code>io.DisplayFrameBufferSize</code> to your window pixel density (macOS/iOS only).</li>
<li>Update mouse cursor shape is supported.</li>
</ul>
<p><b>In your <code>ImGui_ImplXXX_NewFrame()</code> function or event handlers:</b></p><ul>
<li><b>Mouse Support</b><ul>
<li>Use <code>io.AddMousePosEvent()</code>, <code>io.AddMouseButtonEvent()</code>, <code>io.AddMouseWheelEvent()</code> to pass mouse events.</li>
<li>Use <code>io.AddMouseSourceEvent()</code> if you are able to distinguish Mouse from TouchScreen from Pen inputs. TouchScreen and Pen inputs requires different logic for some Dear ImGui features.</li>
<li>Use <code>io.AddMouseViewportEvent()</code> to specify which viewport/OS window is being hovered by the mouse. Read instructions carefully as this is not as simple as it seems! (multi-viewports only)</li>
</ul>
</li>
<li><b>Keyboard Support</b><ul>
<li>Use <code>io.AddKeyEvent()</code> to pass key events.</li>
<li>Use <code>io.AddInputCharacter()</code> to pass text/character events.</li>
</ul>
</li>
<li><b>Gamepad Support</b><ul>
<li>Use <code>io.AddKeyEvent()</code> and <code>io.AddKeyAnalogEvent()</code> to pass gamepad events, using <code>ImGuiKey_GamepadXXX</code> values.</li>
</ul>
</li>
<li><b>Miscellaneous</b><ul>
<li>Clipboard Support: setup <code>Platform_GetClipboardTextFn()</code>, <code>Platform_SetClipboardTextFn()</code> handlers in <code>ImGuiPlatformIO</code>.</li>
<li>Open in Shell support: setup <code>Platform_OpenInShellFn()</code> handler in <code>ImGuiPlatformIO</code>.</li>
<li>IME Support: setup <code>Platform_SetImeDataFn()</code> handler in <code>ImGuiPlatformIO</code>.</li>
<li>Use <code>io.AddFocusEvent()</code> to notify when application window gets focused/unfocused.</li>
</ul>
</li>
<li><b>Multi-viewport Support</b><ul>
<li>Update monitor list if supported.</li>
<li>Setup all required handlers in <code>ImGuiPlatformIO</code> to create/destroy/move/resize/title/focus/etc. windows.</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md56"></a>
Rendering: Implementing your RenderDrawData function</h3>
<p>Note: set <code>ImGuiBackendFlags_RendererHasVtxOffset</code> to signify your backend can handle rendering with a vertex offset (<code>ImDrawCmd::VtxOffset</code> field). Otherwise, rendering will be limited to 64K vertices per window, which may be limiting for advanced plot. As an alternative, you may also use <code>#define ImDrawIdx unsigned int</code> in your <code>imconfig.h</code> file to support 32-bit indices.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyImGuiBackend_RenderDrawData(ImDrawData* draw_data)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// TODO: Update textures.</span></div>
<div class="line">    <span class="comment">// - Most of the times, the list will have 1 element with an OK status, aka nothing to do.</span></div>
<div class="line">    <span class="comment">// - This almost always points to ImGui::GetPlatformIO().Textures[] but is part of ImDrawData to allow overriding or disabling texture updates.</span></div>
<div class="line">    <span class="keywordflow">if</span> (draw_data-&gt;Textures != <span class="keyword">nullptr</span>)</div>
<div class="line">        <span class="keywordflow">for</span> (ImTextureData* tex : *draw_data-&gt;Textures)</div>
<div class="line">            if (tex-&gt;Status != ImTextureStatus_OK)</div>
<div class="line">                MyImGuiBackend_UpdateTexture(tex);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// TODO: Setup render state:</span></div>
<div class="line">    <span class="comment">// - Alpha-blending enabled</span></div>
<div class="line">    <span class="comment">// - No backface culling</span></div>
<div class="line">    <span class="comment">// - No depth testing, no depth writing</span></div>
<div class="line">    <span class="comment">// - Scissor enabled</span></div>
<div class="line">    MyEngineSetupenderState();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// TODO: Setup texture sampling state</span></div>
<div class="line">    <span class="comment">// - Sample with bilinear filtering (NOT point/nearest filtering).</span></div>
<div class="line">    <span class="comment">// - Use &#39;io.Fonts-&gt;Flags |= ImFontAtlasFlags_NoBakedLines;&#39; to allow point/nearest filtering.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// TODO: Setup viewport covering draw_data-&gt;DisplayPos to draw_data-&gt;DisplayPos + draw_data-&gt;DisplaySize</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// TODO: Setup orthographic projection matrix cover draw_data-&gt;DisplayPos to draw_data-&gt;DisplayPos + draw_data-&gt;DisplaySize</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// TODO: Setup shader: vertex { float2 pos, float2 uv, u32 color }, fragment shader sample color from 1 texture, multiply by vertex color.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Render command lists</span></div>
<div class="line">    ImVec2 clip_off = draw_data-&gt;DisplayPos;</div>
<div class="line">    ImVec2 clip_scale = draw_data-&gt;FramebufferScale;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> ImDrawList* draw_list : draw_data-&gt;CmdLists)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> ImDrawVert* vtx_buffer = cmd_list-&gt;VtxBuffer.Data;  <span class="comment">// vertex buffer generated by Dear ImGui</span></div>
<div class="line">        <span class="keyword">const</span> ImDrawIdx* idx_buffer = cmd_list-&gt;IdxBuffer.Data;   <span class="comment">// index buffer generated by Dear ImGui</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> cmd_i = 0; cmd_i &lt; cmd_list-&gt;CmdBuffer.Size; cmd_i++)</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">const</span> ImDrawCmd* pcmd = &amp;cmd_list-&gt;CmdBuffer[cmd_i];</div>
<div class="line">            <span class="keywordflow">if</span> (pcmd-&gt;UserCallback)</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">if</span> (pcmd-&gt;UserCallback == ImDrawCallback_ResetRenderState)</div>
<div class="line">                    MyEngineSetupenderState();</div>
<div class="line">                <span class="keywordflow">else</span></div>
<div class="line">                    pcmd-&gt;UserCallback(cmd_list, pcmd);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line">                <span class="comment">// Project scissor/clipping rectangles into framebuffer space</span></div>
<div class="line">                <span class="comment">// - Clipping coordinates are provided in imgui coordinates space:</span></div>
<div class="line">                <span class="comment">//   - For a given viewport, draw_data-&gt;DisplayPos == viewport-&gt;Pos and draw_data-&gt;DisplaySize == viewport-&gt;Size</span></div>
<div class="line">                <span class="comment">//   - In a single viewport application, draw_data-&gt;DisplayPos == (0,0) and draw_data-&gt;DisplaySize == io.DisplaySize, but always use GetMainViewport()-&gt;Pos/Size instead of hardcoding those values.</span></div>
<div class="line">                <span class="comment">//   - In the interest of supporting multi-viewport applications (see &#39;docking&#39; branch on github),</span></div>
<div class="line">                <span class="comment">//     always subtract draw_data-&gt;DisplayPos from clipping bounds to convert them to your viewport space.</span></div>
<div class="line">                <span class="comment">// - Note that pcmd-&gt;ClipRect contains Min+Max bounds. Some graphics API may use Min+Max, other may use Min+Size (size being Max-Min)</span></div>
<div class="line">                ImVec2 clip_min((pcmd-&gt;ClipRect.x - clip_off.x) * clip_scale.x, (pcmd-&gt;ClipRect.y - clip_off.y) * clip_scale.y);</div>
<div class="line">                ImVec2 clip_max((pcmd-&gt;ClipRect.z - clip_off.x) * clip_scale.x, (pcmd-&gt;ClipRect.w - clip_off.y) * clip_scale.y);</div>
<div class="line">                <span class="keywordflow">if</span> (clip_max.x &lt;= clip_min.x || clip_max.y &lt;= clip_min.y)</div>
<div class="line">                    <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">                <span class="comment">// We are using scissoring to clip some objects. All low-level graphics API should support it.</span></div>
<div class="line">                <span class="comment">// - If your engine doesn&#39;t support scissoring yet, you may ignore this at first. You will get some small glitches</span></div>
<div class="line">                <span class="comment">//   (some elements visible outside their bounds) but you can fix that once everything else works!</span></div>
<div class="line">                MyEngineSetScissor(clip_min.x, clip_min.y, clip_max.x, clip_max.y);</div>
<div class="line"> </div>
<div class="line">                <span class="comment">// The texture for the draw call is specified by pcmd-&gt;GetTexID().</span></div>
<div class="line">                <span class="comment">// The vast majority of draw calls will use the Dear ImGui texture atlas, which value you have set yourself during initialization.</span></div>
<div class="line">                MyEngineBindTexture((MyTexture*)pcmd-&gt;GetTexID());</div>
<div class="line"> </div>
<div class="line">                <span class="comment">// Render &#39;pcmd-&gt;ElemCount/3&#39; indexed triangles.</span></div>
<div class="line">                <span class="comment">// By default the indices ImDrawIdx are 16-bit, you can change them to 32-bit in imconfig.h if your engine doesn&#39;t support 16-bit indices.</span></div>
<div class="line">                MyEngineDrawIndexedTriangles(pcmd-&gt;ElemCount, <span class="keyword">sizeof</span>(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer + pcmd-&gt;IdxOffset, vtx_buffer, pcmd-&gt;VtxOffset);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md57"></a>
Rendering: Adding support for &lt;tt&gt;ImGuiBackendFlags_RendererHasTextures&lt;/tt&gt; (1.92+)</h3>
<p>Version <a href="https://github.com/ocornut/imgui/releases/tag/v1.92.0">1.92.0</a> (June 2025), added texture support in Rendering Backends, which is the backbone for supporting dynamic font scaling among other things.</p>
<p><b>In order to move forward and take advantage of all new features, support for <code>ImGuiBackendFlags_RendererHasTextures</code> will likely be REQUIRED for all backends before June 2026.</b></p>
<p><code>ImFontAtlas</code> functions such as <code>Build()</code>, <code>GetTexDataAsRGBA32()</code>, <code>GetTexDataAsAlpha8()</code>, <code>SetTexID()</code>, <code>IsBuilt()</code> were obsoleted in favor if iterating a <code>Textures[]</code> array and updating their state when requested by Dear ImGui.</p>
<p><b>TD;DR: List of commits which added support for <code>ImGuiBackendFlags_RendererHasTextures</code> in standard backends:</b></p>
<ul>
<li>Allegro5: <a href="https://github.com/ocornut/imgui/commit/ee8941e">ee8941e</a> (+35 lines)</li>
<li>DirectX9: <a href="https://github.com/ocornut/imgui/commit/75efba7">75efba7</a> (+48 lines)</li>
<li>DirectX10: <a href="https://github.com/ocornut/imgui/commit/2d2b1bc">2d2b1bc</a> (+40 lines)</li>
<li>DirectX11: <a href="https://github.com/ocornut/imgui/commit/372fd27">372fd27</a> (+40 lines)</li>
<li>DirectX12: <a href="https://github.com/ocornut/imgui/commit/eefe5d5">eefe5d5</a> (+87 lines)</li>
<li>Metal: <a href="https://github.com/ocornut/imgui/commit/26c017d">26c017d</a> (+55 lines)</li>
<li>OpenGL Legacy: <a href="https://github.com/ocornut/imgui/commit/0430c55">0430c55</a> (+25 lines)</li>
<li>OpenGL3/WebGL/ES: <a href="https://github.com/ocornut/imgui/commit/dbb91a5">dbb91a5</a> (+47 lines)</li>
<li>SDL_Renderer2: <a href="https://github.com/ocornut/imgui/commit/9fa65cd">9fa65cd</a> (+20 lines)</li>
<li>SDL_Renderer3: <a href="https://github.com/ocornut/imgui/commit/e538883">e538883</a> (+19 lines)</li>
<li>SDL_GPU: <a href="https://github.com/ocornut/imgui/commit/16fe666">16fe666</a> (+41 lines)</li>
<li>Vulkan: <a href="https://github.com/ocornut/imgui/commit/abe294b">abe294b</a> (+33 lines)</li>
<li>WGPU: <a href="https://github.com/ocornut/imgui/commit/571dae9">571dae9</a> (+30 lines)</li>
</ul>
<p><b>Instructions:</b></p>
<ul>
<li>Set <code>ImGuiBackendFlags_RendererHasTextures</code> to signify your backend can handle the feature.</li>
<li>During rendering, e.g. in your RenderDrawData function, iterate <code>ImDrawData-&gt;Textures</code> array and process all textures.</li>
<li>During shutdown, iterate the <code>ImGui::GetPlatformIO().Textures</code> and destroy all textures.</li>
<li>(Both arrays are <code>ImVector&lt;ImTextureData*&gt;</code>. They are only in different location because: to allow advanced users to perform multi-threaded rendering, we store a pointer to the texture list in ImDrawData, with the aim that multi-threaded rendering users replace it with their own pointer.)</li>
</ul>
<p>Pseudo-code for processing a texture: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (draw_data-&gt;Textures != <span class="keyword">nullptr</span>)</div>
<div class="line">    <span class="keywordflow">for</span> (ImTextureData* tex : *draw_data-&gt;Textures)</div>
<div class="line">        if (tex-&gt;Status != ImTextureStatus_OK)</div>
<div class="line">            MyImGuiBackend_UpdateTexture(tex);</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keywordtype">void</span> MyImGuiBackend_UpdateTexture(ImTextureData* tex)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (tex-&gt;Status == ImTextureStatus_WantCreate)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Create texture based on tex-&gt;Width, tex-&gt;Height.</span></div>
<div class="line">        <span class="comment">// - Most backends only support tex-&gt;Format == ImTextureFormat_RGBA32.</span></div>
<div class="line">        <span class="comment">// - Backends for particularly memory constrainted platforms may support tex-&gt;Format == ImTextureFormat_Alpha8.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Upload all texture pixels</span></div>
<div class="line">        <span class="comment">// - Read from our CPU-side copy of the texture and copy to your graphics API.</span></div>
<div class="line">        <span class="comment">// - Use tex-&gt;Width, tex-&gt;Height, tex-&gt;GetPixels(), tex-&gt;GetPixelsAt(), tex-&gt;GetPitch() as needed.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Store your data, and acknowledge creation.</span></div>
<div class="line">        tex-&gt;SetTexID(xxxx); <span class="comment">// Specify backend-specific ImTextureID identifier which will be stored in ImDrawCmd.</span></div>
<div class="line">        tex-&gt;SetStatus(ImTextureStatus_OK);</div>
<div class="line">        tex-&gt;BackendUserData = xxxx; <span class="comment">// Store more backend data if needed (most backend allocate a small texture to store data in there)</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (tex-&gt;Status == ImTextureStatus_WantUpdates)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Upload a rectangle of pixels to the existing texture</span></div>
<div class="line">        <span class="comment">// - We only ever write to textures regions which have never been used before!</span></div>
<div class="line">        <span class="comment">// - Use tex-&gt;TexID or tex-&gt;BackendUserData to retrieve your stored data.</span></div>
<div class="line">        <span class="comment">// - Use tex-&gt;UpdateRect.x/y, tex-&gt;UpdateRect.w/h to obtain the block position and size.</span></div>
<div class="line">        <span class="comment">//   - Use tex-&gt;Updates[] to obtain individual sub-regions within tex-&gt;UpdateRect. Not recommended.</span></div>
<div class="line">        <span class="comment">// - Read from our CPU-side copy of the texture and copy to your graphics API.</span></div>
<div class="line">        <span class="comment">// - Use tex-&gt;Width, tex-&gt;Height, tex-&gt;GetPixels(), tex-&gt;GetPixelsAt(), tex-&gt;GetPitch() as needed.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Acknowledge update</span></div>
<div class="line">        tex-&gt;SetStatus(ImTextureStatus_OK);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (tex-&gt;Status == ImTextureStatus_WantDestroy &amp;&amp; tex-&gt;UnusedFrames &gt; 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// If you use staged rendering and have in-flight renders, changed tex-&gt;UnusedFrames &gt; 0 check to higher count as needed e.g. &gt; 2</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Destroy texture</span></div>
<div class="line">        <span class="comment">// - Use tex-&gt;TexID or tex-&gt;BackendUserData to retrieve your stored data.</span></div>
<div class="line">        <span class="comment">// - Destroy texture in your graphics API.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Acknowledge destruction</span></div>
<div class="line">        tex-&gt;SetTexID(ImTextureID_Invalid);</div>
<div class="line">        tex-&gt;SetStatus(ImTextureStatus_Destroyed);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> Refer to "List of commits which added support for `ImGuiBackendFlags_RendererHasTextures` in standard backends" above for concrete examples of this. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
